IMPORT foolib;

::foo FUNCTION(%a I32, %b I32): I32
{
  RETURN a + b;
}

::option_num OPTION NUMBER DEFAULT(42);

::runtime_main INCLUDE_IF(ARCH_ARM64) ASM_PROCEDURE ARM LINKNAME("_start")
  CALLABLE(X1 I32, X2 I32)
{
  MOV X7, 1; // Comment
  ADD X3, X4, X5;
  LDR X1, PROCEDURE_REF("stdcall", main#());
  SVC 0;
}

::buz CLASS
{
  .x VAR I32;

  .CONSTRUCTOR FUNCTION()
  {
     .x := 9;
  }

  .DESTRUCTOR FUNCTION()
  {

  }

  .foo FUNCTION()
  {
    .x := .x + 1;
  }
}

::arch_int INCLUDE_IF(ARCH_X64 && OS_LINUX ) FUNCTION(): I32
{
  RETURN 2;
}

::arch_int INCLUDE_IF(ARCH_ARM64) FUNCTION(): I32
{
  RETURN 1;
}

// ::arch_int INCLUDE_IF(ARCH_ARM64) FUNCTION(): I32
// {
//  RETURN 3;
// }

::buf FUNCTION(%a MUT& I32)
{
    VAR zz yak;
    zz.z := a<-;
}

::biz FUNCTION(%a I32, %b I32): I32
{
  VAR y I32;

  VAR q [3]I32;

  q[0] := 1;
  q[1] := 2;
  q[2] := 3;


  IF (y == 0) {
    VAR x yak;

    x.z := y<-;

    x.f := q[& 0];
    x.f_count := 3;
  }
  buf(a);
  RETURN a + b + y + q[0] + q[1] + q[2] + 1;
}


::mif FUNCTION(): I64
{
  VAR x [4]I64;
  x[0] := 1;
  x[1] := 2;
  x[2] := 3;
  x[3] := 4;


  RETURN x[0] + x[1] + x[2] + x[3];
}


// [4]->I32
// ->  [4]I32
// ->  [4]->I32
// =>> I32
// [4]I32

// *I32
// ^I32


::boq FUNCTION(): I32
{
  RETURN 5;
}

::boq FUNCTION(%a I32): I32
{
  RETURN a + 5;
}

::yip FUNCTION(%a AUTO(t1)) : t1
{
  RETURN a + 1;
}

::yip FUNCTION(): I32
{
  VAR x I32;
  x := 7;
  RETURN yip(x);
}


::xip FUNCTION() :I32
{
  VAR x I32;
  x := 8;
  ASSERT (x == 8);

  test_dtor_executes();
  test_arry_pointers();
  test_argument_passing();
  test_swap();
  test_call_function_from_other_file();
  test_call_imported_function();
  test_class_default_copy_works();
  test_array_arithmetic();
    test_roman_numeral();

  RETURN 1;
}





::yak_dtors FUNCTION(%a yak, %b &I32): I32
{
  a.z := b<-;
  RETURN 1;
}

::test_dtor_executes FUNCTION()
{
  VAR x I32;

  {
    VAR y yak;
    y.z := x<-;
  }

  ASSERT (x == 1);

  yak_dtors(yak() , x);

  ASSERT (x == 2);
}

::test_arry_pointers FUNCTION()
{
  VAR x [4]I32;
  x[0] := 1;
  x[1] := 2;
  x[2] := 3;
  x[3] := 4;

  {
    VAR y yak;

    y.f := x[& 0];
    y.f_count := 3;
  }

  ASSERT (x[0] == 2);
  ASSERT (x[1] == 3);
  ASSERT (x[2] == 4);
  ASSERT (x[3] == 4);
}


::test_lambda FUNCTION()
{
  VAR x I32;

 // AUTO z := ~
 // {
 //   x++;
 // };

}

::bam CLASS
{
  .x VAR I32;
  .y VAR -> I32;

  .CONSTRUCTOR FUNCTION(@OTHER CONST& bam)
  {
    .x := OTHER.x;
    .y := OTHER.y;
  }

  ::static_function FUNCTION(): I32
  {
    RETURN 3;
  }

  .CONSTRUCTOR FUNCTION(@OTHER TEMP& bam)
  {
    .x <-> OTHER.x;
    .y <-> OTHER.y;
  }

  .DESTRUCTOR FUNCTION()
  {
    IF (.y??)
    {
        .y-> := .y-> + 1;
    }
  }
}


::roman CLASS
{
  .value VAR I32;

  .CONSTRUCTOR FUNCTION(@OTHER STRING_CONSTANT)
  {
     VAR it CONST=>> BYTE := OTHER.BEGIN();
     VAR end CONST=>> BYTE := OTHER.END();

     WHILE (it < end)
     {
        // This code is a bit ugly, but I haven't implemented character literals yet
        IF (it-> == STRING_CONSTANT(@OTHER "I").BEGIN()->)
        {
          .value := .value + 1;
        }
        ELSE IF (it-> == STRING_CONSTANT(@OTHER "V").BEGIN()->)
        {
          .value := .value + 5;
        }
        it++;
     }
  }

}

::test_swap FUNCTION()
{
    VAR a I32;
    VAR y I32;

    a := 5;
    y := 10;

    a <-> y;

    ASSERT(a == 10);
    ASSERT(y == 5);
}

::test_call_function_from_other_file FUNCTION()
{
  VAR x I32;

  x := other_file_function();

  ASSERT(x == 42);
}


::test_call_imported_function FUNCTION()
{
   VAR x I32;

   x := foolib::imported_function();

   ASSERT(x == 42);
}

::test_array_arithmetic FUNCTION()
{
  VAR a [4]I32;
  VAR ptr1 =>> I32;
  VAR ptr2 =>> I32;

  ptr1 := a[& 0];
  ptr2 := a[& 1];

  ASSERT(ptr1 < ptr2);

  ASSERT(ptr2 > ptr1);

  ASSERT(ptr1 != ptr2);

  ptr1++;

  ASSERT(ptr1 == ptr2);
}

::test_roman_numeral FUNCTION()
{
  VAR r roman;
  VAR i I32 := 4;
  ASSERT(i == 4);
  r := roman(@OTHER STRING_CONSTANT(@OTHER "VIII"));

  ASSERT(r.value == 8);

}

::class_default_copy_class CLASS
{
  .x VAR I32;
}

::test_class_default_copy_works FUNCTION()
{

    VAR a class_default_copy_class;
    a.x := 5;

    VAR b class_default_copy_class; // := a;
    b := a;

    ASSERT(b.x == 5);
}


::test_argument_passing FUNCTION()
{
  VAR b bam;
  b.x := 5;
  VAR i I32;
  b.y := i<-;

  test_argument_passing_helper(@int i, @arg b);

  ASSERT(i == 6);
}


::test_argument_passing2 STATIC_TEST
{
  VAR b bam;
  b.x := 5;
  VAR i I32;
  b.y := i<-;

  test_argument_passing_helper(@arg b, @int i);

  ASSERT(i == 6);
}


::test_bitwise_operators FUNCTION()
{
   VAR a I32 := 3;

   // a := a #++ 1;

   // ASSERT(a == 6);

   // a := 4;
   //  a := a #-- 1;

   // ASSERT(a == 2);

   // a := a #++ 2;

   // ASSERT(a == 8);
}

::test_argument_passing_helper FUNCTION(@arg bam, @int & I32)
{
   int := int + arg.x;
}



::yak CLASS
{
   .z VAR -> I32;
   .f VAR =>> I32;
   .f_count VAR SZ;



   .DESTRUCTOR FUNCTION()
   {
     IF (.z??)
     {
        .z-> := .z-> + 1;
     }

     IF (.f??)
     {
        WHILE(.f_count > 0)
        {
           .f-> ++;
           // .f := .f + 1;
           .f++;
           .f--;
           .f++;
           .f_count := .f_count - 1;
        }
     }
   }
}


::pinc_test FUNCTION() : I32
{

  VAR x [3 + foobar()]I32;
  x[0] := 0;
  x[1] := 0;
  x[2] := 0;
  x[3] := 0;

  VAR y =>> I32;

  y := x[& 0];

  y++;
  y++;
  y--;

  y-> ++ ;
  y-> ++ ;

  VAR three I32;
  three := 3;
  ASSERT (three == 3);

  RETURN x[1] ;
}

::pinc_test2 STATIC_TEST
{
  ASSERT (3 == 4);
}

::main FUNCTION(): I32
{
  VAR x I32;
  x := 1;
  VAR y I32;
  y := 3;
  ::foo( 3 ,  8 );
  VAR z buz;
  z.foo();
  VAR a ->I32;
  a := z.x <-;
  a-> := a-> + 5;

  VAR bz yak;

  RETURN 4;
}

::foobar FUNCTION(): U64
{
  VAR x U64;
  x := 1;
  RETURN x;
}
