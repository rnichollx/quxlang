MODULE main;

::foo FUNCTION(%a I32, %b I32): I32
{
  RETURN a + b;
}



::runtime_main INCLUDE_IF(TARGET("CPU") == "ARM64") ASM_PROCEDURE ARM LINKNAME("_start")
  CALLABLE(X1 I32, X2 I32)
{
  MOV X7, 1; // Comment
  ADD X3, X4, X5;
  LDR X1, PROCEDURE_REF("stdcall", main#());
  SVC 0;
}

::buz CLASS
{
  .x VAR I32;

  .CONSTRUCTOR FUNCTION()
  {
     .x := 9;
  }

  .DESTRUCTOR FUNCTION()
  {

  }

  .foo FUNCTION()
  {
    .x := .x + 1;
  }
}

::buf FUNCTION(%a MUT& I32)
{
    VAR zz yak;
    zz.z := a<-;
}

::biz FUNCTION(%a I32, %b I32): I32
{
  VAR y I32;
  IF (y == 0) {
    VAR x yak;

    x.z := y<-;
  }
  buf(a);
  RETURN a + b + y;
}


::mif FUNCTION(): I64
{
  VAR x [4]I64;
  x[0] := 1;
  x[1] := 2;
  x[2] := 3;
  x[3] := 4;

  {
    VAR q yak;

  }

  RETURN x[0] + x[1] + x[2] + x[3];
}


::boq FUNCTION(): I32
{
  RETURN 5;
}


::yak CLASS
{
   .z VAR -> I32;
   .f VAR =>> I32;
   .f_count VAR SZ;

   .DESTRUCTOR FUNCTION()
   {
     IF (.z??)
     {
        .z-> := .z-> + 1;
     }

     IF (.f??)
     {
        WHILE(.f_count > 0)
        {
           .f-> ++;
           .f_count := .f_count - 1;
        }
     }
   }
}

::main FUNCTION(): I32
{
  VAR x I32;
  x := 1;
  VAR y I32;
  y := 3;
  ::foo( 3 ,  8 );
  VAR z buz;
  z.foo();
  VAR a ->I32;
  a := z.x <-;
  a-> := a-> + 5;

  VAR bz yak;

  RETURN 4;
}