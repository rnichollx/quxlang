IMPORT foolib;


::constexpr_test_suite FUNCTION() :I32
{
  test_runtime_statement();
  test_dtor_executes();
  test_arry_pointers();
  test_array_ctor();
  test_argument_passing();
  test_swap();
  test_serialize();
  test_call_function_from_other_file();
  test_call_imported_function();
  test_class_default_copy_works();
  test_array_arithmetic();
  test_roman_numeral();
  test_implicit_conversions();
  test_type_exprs();
  test_rhs_comparisons();
  test_bits();
  test_include_if_overloads();

  RETURN 1;
}

::test_serialize FUNCTION()
{
   VAR output [4]BYTE;

   VAR x I32 := 255;

   x.SERIALIZE( @OUTPUT_ITERATOR output[& 0] );
}


::arrytest_cls CLASS
{
  .val VAR I32;

  .CONSTRUCTOR FUNCTION()
  {
     .val := 5;
  }
}

::test_array_ctor FUNCTION()

{
    VAR x [3]arrytest_cls;

    ASSERT( x[0].val == 5 );
    ASSERT( x[1].val == 5 );
    ASSERT( x[2].val == 5 );
}

::test_array_literal FUNCTION() {
   UNIMPLEMENTED;

   // VAR x [4]I32 :[ 1, 3, 5, 7 ];

   ASSERT( x[0] == 1 );
   ASSERT( x[1] == 3 );
   ASSERT( x[2] == 5 );
   ASSERT( x[3] == 7 );

}


::test_runtime_statement FUNCTION()
{

   VAR x I32;

   RUNTIME CONSTEXPR {
      x := 10;
   } ELSE {
      x := 20;
   }
   ASSERT( x == 10 );

   RUNTIME NATIVE {
      x := 30;
   } ELSE {
      x := 40;
   }

   ASSERT( x == 40 );

}

::string CLASS
{
   .data VAR =>> BYTE;
   .length VAR SZ;
   .capacity VAR SZ;


   .CONSTRUCTOR FUNCTION( @OTHER STRING_CONSTANT )
   {
      VAR len SZ := OTHER.END() - OTHER.BEGIN();
      .length := len;
      RUNTIME CONSTEXPR {
      // Need to implement constexpr allocator.
      //  .data = CONSTEXPR_ALLOC(BYTE, len);
      } ELSE {
        // Native runtime, need to write standard library allocator first
        UNIMPLEMENTED;
      }
   }

   .push_back FUNCTION( @val BYTE )
   {
     IF ( .capacity > .length )
     {
        PLACE AT(.data + .length) BYTE := val;
        .length++;
     } ELSE {
        UNIMPLEMENTED;
     }
   }

   .pop_back FUNCTION()
   {
      DESTROY AT(.data + .length - 1) BYTE;
      .length--;
   }
}



::foo FUNCTION(%a I32, %b I32): I32
{
  RETURN a + b;
}

::option_num OPTION NUMBER DEFAULT(42);

::runtime_main INCLUDE_IF(ARCH_ARM64) ASM_PROCEDURE ARM LINKNAME("_start")
  CALLABLE(X1 I32, X2 I32)
{
  MOV X7, 1; // Comment
  ADD X3, X4, X5;
  LDR X1, PROCEDURE_REF("stdcall", main#());
  SVC 0;
}

::buz CLASS
{
  .x VAR I32;

  .CONSTRUCTOR FUNCTION()
  {
     .x := 9;
  }

  .DESTRUCTOR FUNCTION()
  {

  }

  .foo FUNCTION()
  {
    .x := .x + 1;
  }
}

::arch_int INCLUDE_IF(ARCH_X64 && OS_LINUX ) FUNCTION(): I32
{
  RETURN 2;
}

::arch_int INCLUDE_IF(ARCH_ARM64) FUNCTION(): I32
{
  RETURN 1;
}

// ::arch_int INCLUDE_IF(ARCH_ARM64) FUNCTION(): I32
// {
//  RETURN 3;
// }

::buf FUNCTION(%a MUT& I32)
{
    VAR zz yak;
    zz.z := a<-;
}

::biz FUNCTION(%a I32, %b I32): I32
{
  VAR y I32;

  VAR q [3]I32;

  q[0] := 1;
  q[1] := 2;
  q[2] := 3;


  IF (y == 0) {
    VAR x yak;

    x.z := y<-;

    x.f := q[& 0];
    x.f_count := 3;
  }
  buf(a);
  RETURN a + b + y + q[0] + q[1] + q[2] + 1;
}


::mif FUNCTION(): I64
{
  VAR x [4]I64;
  x[0] := 1;
  x[1] := 2;
  x[2] := 3;
  x[3] := 4;


  RETURN x[0] + x[1] + x[2] + x[3];
}


// [4]->I32
// ->  [4]I32
// ->  [4]->I32
// =>> I32
// [4]I32

// *I32
// ^I32


::boq FUNCTION(): I32
{
  RETURN 5;
}

::boq FUNCTION(%a I32): I32
{
  RETURN a + 5;
}

::yip FUNCTION(%a AUTO(t1)) : t1
{
  RETURN a + 1;
}

::yip FUNCTION(): I32
{
  VAR x I32;
  x := 7;
  RETURN yip(x);
}

::test_type_exprs FUNCTION()
{
  VAR x I32;
  x := 4;

  // ASSERT( SIZEOF(I32) == 4  );

  ASSERT( SIZEOF(I32)  == x );

  x := 32;

  ASSERT( BITS(I32) == x );


}


::include_if_helper FUNCTION(%a AUTO(t1)) ENABLE_IF( BITS(t1) < 32 AS I32 ): I32
{
  RETURN 1;
}

::include_if_helper FUNCTION(%a AUTO(t1)) ENABLE_IF( BITS(t1) == 32 AS I64 ): I32
{
  RETURN 2;
}

::include_if_helper FUNCTION(%a AUTO(t1)) ENABLE_IF( BITS(t1) > 32 AS I32 ): I32
{
  RETURN 3;
}
::test_include_if_overloads FUNCTION()
{
    VAR x I32;

    x := include_if_helper( 0 AS I16 );
    ASSERT( x == 1 );

    x := include_if_helper( 0 AS I32 );
    ASSERT( x == 2 );

    x := include_if_helper( 0 AS I64 );
    ASSERT( x == 3 );
}

::test_rhs_comparisons FUNCTION()
{
    VAR x I32 := 5;

    ASSERT( x == 5 );
    ASSERT( 5 == x );

    ASSERT( x != 6 );
    ASSERT( 6 != x );

    ASSERT( x < 6 );
    ASSERT( 4 < x );

    ASSERT( x > 4 );
    ASSERT( 6 > x );

    ASSERT( x >= 5 );
    ASSERT( 6 >= x );

    ASSERT( x <= 6 );
    ASSERT( 5 <= x );






    ASSERT( x >= 4 );
    ASSERT( 4 <= x );

}

::test_bits FUNCTION()
{
   VAR xbits I32;


   xbits := BITS(I32);

   ASSERT(xbits == 32);

   VAR b BOOL;
   b := BITS(I16) < 32 AS I32;

   ASSERT( b == TRUE );


}






::yak_dtors FUNCTION(%a yak, %b &I32): I32
{
  a.z := b<-;
  RETURN 1;
}

::test_dtor_executes FUNCTION()
{
  VAR x I32;

  {
    VAR y yak;
    y.z := x<-;
  }

  ASSERT (x == 1);

  yak_dtors(yak() , x);

  ASSERT (x == 2);
}

::test_arry_pointers FUNCTION()
{
  VAR x [4]I32;
  x[0] := 1;
  x[1] := 2;
  x[2] := 3;
  x[3] := 4;

  {
    VAR y yak;

    y.f := x[& 0];
    y.f_count := 3;
  }

  ASSERT (x[0] == 2);
  ASSERT (x[1] == 3);
  ASSERT (x[2] == 4);
  ASSERT (x[3] == 4);
}


::test_lambda FUNCTION()
{
  VAR x I32;

 // AUTO z := -<
 // {
 //   x++;
 // };

}

::bam CLASS
{
  .x VAR I32;
  .y VAR -> I32;

  .CONSTRUCTOR FUNCTION(@OTHER CONST& bam)
  {
    .x := OTHER.x;
    .y := OTHER.y;
  }

  ::static_function FUNCTION(): I32
  {
    RETURN 3;
  }

  .CONSTRUCTOR FUNCTION(@OTHER TEMP& bam)
  {
    .x <-> OTHER.x;
    .y <-> OTHER.y;
  }

  .DESTRUCTOR FUNCTION()
  {
    IF (.y??)
    {
        .y-> := .y-> + 1;
    }
  }
}


::roman CLASS
{
  .value VAR I32;

  .CONSTRUCTOR FUNCTION(@OTHER STRING_CONSTANT)
  {
     VAR it CONST=>> BYTE := OTHER.BEGIN();
     VAR end CONST=>> BYTE := OTHER.END();

     WHILE (it < end)
     {
        IF (it-> == 'I')
        {
          .value := .value + 1;
        }
        ELSE IF (it-> == ("V" AS STRING_CONSTANT).BEGIN()->)
        {
          .value := .value + 5;
        }
        it++;
     }
  }

}

::test_swap FUNCTION()
{
    VAR a I32;
    VAR y I32;

    a := 5;
    y := 10;

    a <-> y;

    ASSERT(a == 10);
    ASSERT(y == 5);
}

::test_call_function_from_other_file FUNCTION()
{
  VAR x I32;

  x := other_file_function();

  ASSERT(x == 42);
}


::test_call_imported_function FUNCTION()
{
   VAR x I32;

   x := foolib::imported_function();

   ASSERT(x == 42);
}

::test_array_arithmetic FUNCTION()
{
  VAR a [4]I32;
  VAR ptr1 =>> I32;
  VAR ptr2 =>> I32;

  ptr1 := a[& 0];
  ptr2 := a[& 1];

  ASSERT(ptr1 < ptr2);

  ASSERT(ptr2 > ptr1);

  ASSERT(ptr1 != ptr2);

  ptr1++;

  ASSERT(ptr1 == ptr2);
}

::test_roman_numeral FUNCTION()
{
  VAR r roman;
  VAR i I32 := 4;
  ASSERT(i == 4);
  r := "VIII" AS STRING_CONSTANT AS roman;

  ASSERT(r.value == 8);

}

::class_default_copy_class CLASS
{
  .x VAR I32;
}

::test_class_default_copy_works FUNCTION()
{

    VAR a class_default_copy_class;
    a.x := 5;

    VAR b class_default_copy_class; // := a;
    b := a;

    ASSERT(b.x == 5);
}


::test_argument_passing FUNCTION()
{
  VAR b bam;
  b.x := 5;
  VAR i I32;
  b.y := i<-;

  test_argument_passing_helper(@int i, @arg b);

  ASSERT(i == 6);
}


::test_argument_passing2 STATIC_TEST
{
  VAR b bam;
  b.x := 5;
  VAR i I32;
  b.y := i<-;

  test_argument_passing_helper(@arg b, @int i);

  ASSERT(i == 6);
}


::test_bitwise_operators FUNCTION()
{
   VAR a I32 := 3;

   // a := a #++ 1;

   // ASSERT(a == 6);

   // a := 4;
   //  a := a #-- 1;

   // ASSERT(a == 2);

   // a := a #++ 2;

   // ASSERT(a == 8);
}

::test_argument_passing_helper FUNCTION(@arg bam, @int & I32)
{
   int := int + arg.x;
}


::implicit_foo CLASS
{
    .x VAR I32;

    .CONSTRUCTOR FUNCTION(@OTHER I32)
    {
        .x := OTHER;
    }
}

::test_implicit_conversions FUNCTION()
{
    VAR a implicit_foo;
    a := I32(@OTHER 5);

    ASSERT(a.x == 5);

    VAR b I32 := 8;
    a := b;

    ASSERT(a.x == 8);
}




::yak CLASS
{
   .z VAR -> I32;
   .f VAR =>> I32;
   .f_count VAR SZ;



   .DESTRUCTOR FUNCTION()
   {
     IF (.z??)
     {
        .z-> := .z-> + 1;
     }

     IF (.f??)
     {
        WHILE(.f_count > 0)
        {
           .f-> ++;
           // .f := .f + 1;
           .f++;
           .f--;
           .f++;
           .f_count := .f_count - 1;
        }
     }
   }
}


::pinc_test FUNCTION() : I32
{

  VAR x [3 + foobar()]I32;
  x[0] := 0;
  x[1] := 0;
  x[2] := 0;
  x[3] := 0;

  VAR y =>> I32;

  y := x[& 0];

  y++;
  y++;
  y--;

  y-> ++ ;
  y-> ++ ;

  VAR three I32;
  three := 3;
  ASSERT (three == 3);

  RETURN x[1] ;
}

::pinc_test2 STATIC_TEST
{
  ASSERT (3 == 4);
}

::main FUNCTION(): I32
{
  VAR x I32;
  x := 1;
  VAR y I32;
  y := 3;
  ::foo( 3 ,  8 );
  VAR z buz;
  z.foo();
  VAR a ->I32;
  a := z.x <-;
  a-> := a-> + 5;

  VAR bz yak;

  RETURN 4;
}

::foobar FUNCTION(): U64
{
  VAR x U64;
  x := 1;
  RETURN x;
}
