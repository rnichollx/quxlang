# Copyright 2024 Ryan Nicholl, rnicholl@protonmail.com
# Generated by ChatGPT. Prompts authored by Ryan P. Nicholl.

import os


import re
import subprocess
import argparse
from collections import defaultdict

def normalize_name(name):
    # Remove middle initials
    words = name.split()
    new_words = []
    for word in words:
        if len(word) == 1 or (len(word) == 2 and word.endswith('.')):
            continue  # Skip middle initials
        else:
            new_words.append(word)
    normalized = ' '.join(new_words)
    return normalized.lower()  # Lowercase for consistent comparison

def get_file_authors(file_path):
    cmd = ['git', 'log', '--follow', '--pretty=format:%an|%ae|%ad', '--date=format:%Y', '--', file_path]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        print(f"Error running git log on {file_path}: {result.stderr}")
        return {}
    authors = {}
    for line in result.stdout.strip().split('\n'):
        if not line.strip():
            continue
        try:
            name, email, year = line.strip().split('|')
        except ValueError:
            print(f"Unexpected git log output: {line}")
            continue
        name = name.strip()
        email = email.strip()
        year = year.strip()
        normalized_name = normalize_name(name)
        key = (normalized_name, email.lower())
        if key not in authors:
            authors[key] = {'names': set(), 'years': set()}
        authors[key]['names'].add(name)
        authors[key]['years'].add(year)
    return authors

def format_years(years_set):
    years = sorted(int(year) for year in years_set)
    ranges = []
    if not years:
        return ''
    start = years[0]
    end = years[0]
    for year in years[1:]:
        if year == end + 1:
            end = year
        else:
            if start == end:
                ranges.append(f"{start}")
            else:
                ranges.append(f"{start}-{end}")
            start = end = year
    if start == end:
        ranges.append(f"{start}")
    else:
        ranges.append(f"{start}-{end}")
    return ', '.join(ranges)

def parse_existing_copyrights(lines):
    pattern = re.compile(r'''
        ^\s*
        (?P<comment_marker>//|\#|\*)
        \s*
        Copyright
        (\s*\(c\))?
        \s+
        (?P<years>[\d,\-,\s]+)
        \s+
        (?P<name>[\w\s\.\-]+?)
        [,\s]*
        [<\(\[]?
        (?P<email>[\w\.\+\-]+@[\w\.\-]+)
        [>\)\]]?
        .*$
        ''', re.IGNORECASE | re.VERBOSE)
    in_copyright_block = False
    copyright_comments = []
    license_text = []
    code_starts_at = None
    for i, line in enumerate(lines):
        if re.match(r'^\s*$', line):
            continue  # Skip empty lines
        comment_line = re.match(r'^\s*(//|\#|\*|\/*)', line)
        if comment_line:
            match = pattern.match(line)
            if match:
                in_copyright_block = True
                data = match.groupdict()
                years = set(re.findall(r'\d{4}', data['years']))
                name = data['name'].strip()
                email = data['email'].strip()
                comment_marker = data['comment_marker']
                copyright_comments.append({
                    'line_num': i,
                    'line': line,
                    'years': years,
                    'name': name,
                    'email': email,
                    'comment_marker': comment_marker
                })
            elif in_copyright_block:
                license_text.append((i, line))
            else:
                continue  # Comment outside of copyright block
        else:
            if in_copyright_block:
                code_starts_at = i
                break
    return copyright_comments, license_text, code_starts_at

def remove_created_by_comments(lines):
    indices_to_delete = set()
    for i, line in enumerate(lines):
            # Mark this line for deletion
            indices_to_delete.add(i)
            # Check for preceding empty comment line
            if i > 0 and re.match(r'^\s*(//|\#|\*|\/*)\s*$', lines[i-1]):
                indices_to_delete.add(i-1)
            # Check for subsequent empty comment line
            if i + 1 < len(lines) and re.match(r'^\s*(//|\#|\*|\/*)\s*$', lines[i+1]):
                indices_to_delete.add(i+1)
    # Rebuild the lines, skipping those marked for deletion
    new_lines = [line for idx, line in enumerate(lines) if idx not in indices_to_delete]
    return new_lines

def detect_comment_marker(file_path):
    ext = os.path.splitext(file_path)[1]
    if ext in ['.py', '.sh', '.pl']:
        return '#'
    elif ext in ['.cpp', '.hpp', '.c', '.h', '.java', '.js']:
        return '//'
    else:
        return '#'

def update_file(file_path):
    authors = get_file_authors(file_path)
    if not authors:
        print(f"No git history for {file_path}")
        return

    with open(file_path, 'r') as f:
        lines = f.readlines()
    lines = remove_created_by_comments(lines)

    # Parse existing copyrights
    c_comments, license_text, code_starts_at = parse_existing_copyrights(lines)

    # Build a mapping from (normalized_name, email) to existing comments
    existing_authors = {}
    for c in c_comments:
        normalized_name = normalize_name(c['name'])
        key = (normalized_name.lower(), c['email'].lower())
        existing_authors[key] = c

    # Update existing comments and prepare to add new ones
    updated_lines = lines.copy()

    for author_key, author_data in authors.items():
        normalized_name, email = author_key
        years = author_data['years']
        names = author_data['names']
        # Choose the name with the most characters (i.e., the one with middle initial)
        name = max(names, key=len)
        key = (normalized_name.lower(), email.lower())
        if key in existing_authors:
            c = existing_authors[key]
            all_years = c['years'].union(years)
            formatted_years = format_years(all_years)
            new_line = f"{c['comment_marker']} Copyright {formatted_years} {name}, {email}\n"
            updated_lines[c['line_num']] = new_line
        else:
            # Need to add a new comment
            formatted_years = format_years(years)
            if c_comments:
                # Add after license text
                insert_pos = (license_text[-1][0] + 1) if license_text else (c_comments[-1]['line_num'] + 1)
            else:
                # Add at the top
                insert_pos = 0
            comment_marker = detect_comment_marker(file_path)
            new_comment = f"{comment_marker} Copyright {formatted_years} {name}, {email}\n"
            updated_lines.insert(insert_pos, new_comment)
            # Adjust the line numbers of subsequent lines
            for c in c_comments:
                if c['line_num'] >= insert_pos:
                    c['line_num'] += 1

    with open(file_path, 'w') as f:
        f.writelines(updated_lines)

def main():
    parser = argparse.ArgumentParser(description='Update copyright comments')
    parser.add_argument('paths', nargs='*', help='Files or directories to process')
    args = parser.parse_args()

    # Specify the file extensions you want to process
    extensions = ('.hpp', '.cpp', '.py', '.c', '.h', '.java', '.js')

    files_to_process = []

    if args.paths:
        for path in args.paths:
            if os.path.isfile(path):
                if path.endswith(extensions):
                    files_to_process.append(path)
            elif os.path.isdir(path):
                for root, dirs, files in os.walk(path):
                    for file in files:
                        if file.endswith(extensions):
                            files_to_process.append(os.path.join(root, file))
    else:
        # If no paths are provided, process all files tracked by git
        cmd = ['git', 'ls-files']
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            print(f"Error running git ls-files: {result.stderr}")
            return
        files = result.stdout.strip().split('\n')
        for file_path in files:
            if file_path.endswith(extensions):
                files_to_process.append(file_path)

    for file_path in files_to_process:
        print(f"Processing {file_path}")
        update_file(file_path)

if __name__ == '__main__':
    main()
